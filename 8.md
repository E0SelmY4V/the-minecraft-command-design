本节最后修改于 `2022 / 11 / 12`

# 条件的逻辑运算

我们第2节讲了简单的条件判断。那么众所周知，如果同时有多个条件的话，相互之间一般会存在逻辑。说到逻辑那主要就是与（$and$）、非（$not$）和或（$or$）了，除此之外还有与非（$nand$）、或非（$nor$）、异或（$xor$）和同或（$xnor$）。

> 与就是“若A、B都为真，则A与B为真；否则A与B为假”，也就是“**……而且……**”的意思。符号为$and$或者`&`。
>
> 如果我又“吃饭”又“喝水”，那么“我吃饭**而且**喝水”这件事就发生了；如果“吃饭”、“喝水”至少一个没发生，那么“我吃饭**而且**喝水”就不能说是发生了。

> 非就是“若A为真，则非A为假；否则非A为真”，也就是“**没有……**”的意思。符号为$not$或者`!`。
>
> 如果“我吃饭”这件事没发生，那么“我**没有**吃饭”这件事就发生了；如果我“吃饭”了，那么“我**没有**吃饭”这件事就没发生。

> 或就是“若A、B都为假，则A或B为假；否则A或B为真”，也就是“**……或者……**”的意思。符号为$or$或者`|`。
>
> 如果我既没“吃饭”也没“喝水”，那么我就没有“吃饭**或者**喝水”；如果我“吃饭”和“喝水”这俩件事中至少干了一件事，那么就可以说我“吃饭**或者**喝水”。

> 与非就是“若A、B都为真，则A与非B为假；否则A与非B为真”，也就是“**没有……又……**”的意思。符号为$nand$。
>
> 如果我又“吃饭”又“喝水”，那么“我**没有**吃饭**又**喝水”就没发生；如果“吃饭”、“喝水”至少一个没发生，那么“我**没有**吃饭**又**喝水”。
>
> 可以看出$A\ nand\ B=not\ (A\ and\ B)$。

> 或非就是“若A、B都为假，则A或非B为真；否则A或非B为假”，也就是“**没有……也没有……**”的意思。符号为$nor$。
>
> 如果我既没“吃饭”也没“喝水”，那么我就“**没有**吃饭**也没有**喝水”；如果我“吃饭”和“喝水”这俩件事中至少干了一件事，那么我就不是“**没有**吃饭**也没有**喝水”。
>
> 可以看出$A\ nor\ B=nor\ (A\ or\ B)$。

> 异或就是“若A、B都为真或都为假，则A异或B为假；否则A异或B为真”，也就是 “**……和……不同**”。符号为$xor$。
>
> 如果我“吃饭”，但不“喝水”；或者没“吃饭”，但“喝水”了，那我“吃饭**和**喝水**不同**”这件事就发生了；如果我“吃饭”又“喝水”，或者两个都没干，我就不是“吃饭**和**喝水**不同**”。
>
> 可以看出$A\ xor\ B=(A\ nand\ B)\ and\ (A\ or\ B)=(not\ (A\ and\ B))\ and\ (A\ or\ B)$。

> 同或就是“若A、B都为真或都为假，则A同或B为真；否则A同或B为假”，也就是 “**……像……一样**”。符号为$xnor$。
>
> 如果我“吃饭”又“喝水”，或者两个都没干，就可以说我“吃饭**像**喝水**一样**”如果我“吃饭”，但不“喝水”；或者没“吃饭”，但“喝水”了，那就并非“吃饭**像**喝水**一样**”。
>
> 可以看出$A\ xnor\ B=not\ (A\ xor\ B)=(A\ and\ B)\ or\ (A\ nor\ B)=(A\ and\ B)\ or\ (not\ (A\ or\ B))$。


由此可以看出，与、非、或、与非、或非、异或和同或这七种逻辑，最后都可以用与、非和或这三种逻辑组合得到。

只要实现了与、非和或这三种逻辑，我们就能实现全部七种逻辑。

那么我的世界中能不能实现与、非和或呢？

## 与

命令方块中的与是最容易实现的。在第一节中我们讲条件判断的形式一般是有条件命令方块和选择器。有条件命令方块的实现很简单，只需要把两个有条件命令方块接在一起就可以了。

```
# 例子
# 当重工业玉米的背包里同时有tnt和床时，提示“重工业玉米好帅！！”

[~,~,~,~] clear @a[name=重工业玉米] tnt -1 0
[+,L,+,0] clear @a[name=重工业玉米] bed -1 0
[+,L,+,0] say 重工业玉米好帅！！
```

选择器的实现就更简单了，在方括号中使用逗号把两个条件连接起来就可以。

```
# 例子
# 当有一个人叫重工业玉米且有熊孩子标签时，提示“重工业玉米好帅！！”

[~,~,~,~] execute @a[name=重工业玉米,tag=熊孩子] ~~~ say 重工业玉米好帅！！
```

上面是两个条件都为有条件命令方块或都为选择器时的与。

那如果一个条件是有条件命令方块，另一个条件是选择器呢？貌似这两种形式的条件没法通过简单的方式组合到一起，但是他们之间可以相互转化。我们可以将其都转化为选择器：

```
# 例子
# 当重工业玉米有熊孩子标签，背包里还有tnt时，提示“重工业玉米好帅！！”

[~,~,~,~] clear @a[name=重工业玉米] tnt -1 0
[+,L,+,0] tag @a[name=重工业玉米] add tntWith //将有条件命令方块转化为标签
[+,L,-,0] execute @a[name=重工业玉米,tag=熊孩子,tag=tntWith] ~~~ say 重工业玉米好帅！！
[+,L,-,0] tag @a[tag=tntWith] remove tntWith
```

也可以都转化为有条件命令方块：

```
# 例子
# 当重工业玉米有熊孩子标签，背包里还有tnt时，提示“重工业玉米好帅！！”

[~,~,~,~] clear @a[name=重工业玉米] tnt -1 0
[+,L,+,0] testfor @a[name=重工业玉米,tag=熊孩子] //将标签转化为有条件命令方块
[+,L,+,0] say 重工业玉米好帅！！
```

看起来都转化为有条件命令方块可以少用一个命令方块？别忘了我们[第1节](1.md#选择器)时提到，可以用`execute`代替`testfor`：

```
# 例子
# 当重工业玉米有熊孩子标签，背包里还有tnt时，提示“重工业玉米好帅！！”

[~,~,~,~] clear @a[name=重工业玉米] tnt -1 0
[+,L,+,0] execute @a[name=重工业玉米,tag=熊孩子] ~~~ say 重工业玉米好帅！！
```

这样子就又可以少用一个命令方块。于是我们可以说找到了两个条件类型不同时的与。

至此，全部的与我们都找到了实现方法。

## 非

命令方块中的非一般通过选择器来取反——也就是取补集——来得到。

```
# 例子
# 当有一个人叫重工业玉米且没有熊孩子标签时，提示“重工业玉米太帅了！！”

[~,~,~,~] execute @a[name=重工业玉米,tag=!熊孩子] ~~~ say 重工业玉米太帅了！！
```

对于有条件命令方块的非，可以通过设置一个临时标签来使用选择器取反

```
# 例子
# 当重工业玉米的背包里没有tnt时，提示“重工业玉米太帅了！！”

[~,~,~,~] clear @a[name=重工业玉米] tnt -1 0
[+,L,+,0] tag @a[name=重工业玉米] add 熊孩子
[+,L,-,0] execute @a[name=重工业玉米,tag=!熊孩子] ~~~ say 重工业玉米太帅了！！
[+,L,-,0] tag @a[tag=熊孩子] remove 熊孩子
```

## 或

我的世界中没有直接的或。想要实现或，一般是给两个条件分别搞个命令方块，使满足任意条件就满足第三个条件。再判断第三个条件来实现或。

一般来说，有条件命令方块只能被自己的上一个命令方块满足；而选择器条件由于操作的是实体，可以被任意多个命令方块满足。因为上文“第三个条件”需要能被两个命令方块满足，所以我们的第三个条件只能使用选择器的形式。

```
# 例子
# 当重工业玉米有熊孩子标签或者背包里有tnt时，提示“重工业玉米怎么这么帅！！”

[~,~,~,~] tag @a[name=重工业玉米,tag=熊孩子] add needSay
[+,L,-,0] clear @a[name=重工业玉米] tnt -1 0
[+,L,+,0] tag @a[name=重工业玉米] add needSay
[+,L,-,0] execute @a[tag=needSay] ~~~ say 重工业玉米怎么这么帅！！
[+,L,-,0] tag @a[tag=needSay] remove needSay
```

上面例子中，两个条件分别是“有熊孩子标签”和“背包里有tnt”，而这两个条件满足时都会给重工业玉米增加`needSay`标签来满足第三个条件“有人带`needSay`标签”。通过检测第三个条件有没有被满足，可以实现或。